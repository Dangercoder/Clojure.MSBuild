using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Text;

namespace Clojure.MSBuild.SourceGenerators
{
    [Generator]
    public class ClojureEntryPointGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Get the main namespace from MSBuild properties
            var mainNamespace = GetMainNamespace(context);
            
            // Only generate if we have a main namespace specified
            if (string.IsNullOrEmpty(mainNamespace))
                return;

            // Generate the entry point
            var source = GenerateEntryPoint(mainNamespace);
            context.AddSource("ClojureGeneratedProgram.g.cs", SourceText.From(source, Encoding.UTF8));
        }

        private bool IsClojureExecutable(GeneratorExecutionContext context)
        {
            // Check if OutputType is Exe
            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.OutputType", out var outputType);
            if (outputType?.Equals("Exe", System.StringComparison.OrdinalIgnoreCase) != true)
                return false;

            // Check if ClojureMainNamespace is set
            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.ClojureMainNamespace", out var mainNs);
            return !string.IsNullOrEmpty(mainNs);
        }

        private string GetMainNamespace(GeneratorExecutionContext context)
        {
            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.ClojureMainNamespace", out var mainNamespace);
            return mainNamespace ?? "";
        }

        private string GenerateEntryPoint(string mainNamespace)
        {
            return $@"// <auto-generated/>
using System;
using System.Reflection;
using System.IO;

namespace ClojureGenerated
{{
    public class Program
    {{
        public static void Main(string[] args)
        {{
            try
            {{
                // Initialize Clojure runtime
                var clojureAssembly = Assembly.Load(""Clojure"");
                var rtType = clojureAssembly.GetType(""clojure.lang.RT"");
                var initMethod = rtType.GetMethod(""Init"", BindingFlags.Public | BindingFlags.Static);
                initMethod.Invoke(null, null);
                
                // Set up load path for source files
                var srcPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, ""src"");
                if (Directory.Exists(srcPath))
                {{
                    Environment.SetEnvironmentVariable(""CLOJURE_LOAD_PATH"", srcPath);
                }}
                
                // Load the main namespace
                var loadMethod = rtType.GetMethod(""load"", new[] {{ typeof(string) }});
                
                // Try different paths for the namespace
                string[] paths = {{ ""src/{mainNamespace}"", ""{mainNamespace}"" }};
                bool loaded = false;
                
                foreach (var path in paths)
                {{
                    try
                    {{
                        loadMethod.Invoke(null, new[] {{ path }});
                        loaded = true;
                        break;
                    }}
                    catch
                    {{
                        // Try next path
                    }}
                }}
                
                if (!loaded)
                {{
                    throw new Exception(""Could not load namespace {mainNamespace}"");
                }}
                
                // Get and invoke the -main function
                var varMethod = rtType.GetMethod(""var"", new[] {{ typeof(string), typeof(string) }});
                var mainFn = varMethod.Invoke(null, new[] {{ ""{mainNamespace}"", ""-main"" }});
                
                if (mainFn != null)
                {{
                    // Convert args array to Clojure seq
                    var seqMethod = rtType.GetMethod(""seq"", new[] {{ typeof(object) }});
                    var argsSeq = seqMethod.Invoke(null, new[] {{ args }});
                    
                    var invokeMethod = mainFn.GetType().GetMethod(""invoke"", new[] {{ typeof(object) }});
                    invokeMethod.Invoke(mainFn, new[] {{ argsSeq }});
                }}
                else
                {{
                    Console.WriteLine(""Error: Could not find {mainNamespace}/-main function"");
                    Environment.Exit(1);
                }}
            }}
            catch (Exception ex)
            {{
                Console.WriteLine($""Error running Clojure application: {{ex.Message}}"");
                if (ex.InnerException != null)
                {{
                    Console.WriteLine($""Inner exception: {{ex.InnerException.Message}}"");
                }}
                Environment.Exit(1);
            }}
        }}
    }}
}}";
        }
    }
}